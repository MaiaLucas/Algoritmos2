{"version":3,"sources":["../../src/util/graphOpration.js"],"names":["DFS","graph","vertex","discovered","incidentEdge","forEach","opposite","edge","has","set","DFS_complete","forest","Map","vertices","constructPath","origin","destination","path","step","push","get","unshift","BFS","queue","currentVertex","shift","length"],"mappings":";;;;;AAAA;AACO,IAAMA,oBAAM,SAANA,GAAM,CAACC,KAAD,EAAQC,MAAR,EAAgBC,UAAhB,EAA+B;AAC9CF,UAAMG,YAAN,CAAmBF,MAAnB,EAA2BG,OAA3B,CAAoC,gBAAQ;AACxC,YAAIC,WAAWC,KAAKD,QAAL,CAAcJ,MAAd,CAAf;;AAEA,YAAI,CAACC,WAAWK,GAAX,CAAeF,QAAf,CAAL,EAAgC;AAC5BH,uBAAWM,GAAX,CAAeH,QAAf,EAAyBC,IAAzB;AACAP,gBAAIC,KAAJ,EAAWK,QAAX,EAAqBH,UAArB;AACH;AACJ,KAPD;AAQH,CATM;;AAWP;AACO,IAAMO,sCAAe,SAAfA,YAAe,CAACT,KAAD,EAAW;AACnC,QAAIU,SAAS,IAAIC,GAAJ,EAAb;AADmC;AAAA;AAAA;;AAAA;AAEnC,6BAAmBX,MAAMY,QAAN,EAAnB,8HAAsC;AAAA,gBAA7BX,MAA6B;;AAClC,gBAAI,CAACS,OAAOH,GAAP,CAAWN,MAAX,CAAL,EAA0B;AACtBF,oBAAIC,KAAJ,EAAWC,MAAX,EAAmBS,MAAnB;AACH;AACJ;AANkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQnC,WAAOA,MAAP;AACH,CATM;;AAWA,IAAMG,wCAAgB,SAAhBA,aAAgB,CAACC,MAAD,EAASC,WAAT,EAAsBb,UAAtB,EAAqC;AAC9D,QAAIc,OAAO,EAAX;;AAEA,QAAId,WAAWK,GAAX,CAAeQ,WAAf,CAAJ,EAAkC;AAC9B,YAAIE,OAAOF,WAAX;AACAC,aAAKE,IAAL,CAAUD,IAAV;;AAEA,eAAOA,SAASH,MAAhB,EAAyB;AACrB,gBAAIR,OAAOJ,WAAWiB,GAAX,CAAeF,IAAf,CAAX;AACA,gBAAIZ,WAAWC,KAAKD,QAAL,CAAcY,IAAd,CAAf;AACAD,iBAAKI,OAAL,CAAaf,QAAb;;AAEAY,mBAAOZ,QAAP;AACH;AACJ;;AAED,WAAOW,IAAP;AACH,CAjBM;;AAmBP;AACO,IAAMK,oBAAM,SAANA,GAAM,CAACrB,KAAD,EAAQC,MAAR,EAAgBC,UAAhB,EAA+B;AAC9C,QAAIoB,QAAQ,CAACrB,MAAD,CAAZ;;AAD8C;AAG1C,YAAIsB,gBAAgBD,MAAME,KAAN,EAApB;;AAEAxB,cAAMG,YAAN,CAAmBoB,aAAnB,EAAkCnB,OAAlC,CAA2C,gBAAQ;AAC/C,gBAAIC,WAAWC,KAAKD,QAAL,CAAckB,aAAd,CAAf;;AAEA,gBAAI,CAACrB,WAAWK,GAAX,CAAeF,QAAf,CAAL,EAAgC;AAC5BH,2BAAWM,GAAX,CAAeH,QAAf,EAAyBC,IAAzB;AACAgB,sBAAMJ,IAAN,CAAWb,QAAX;AACH;AACJ,SAPD;AAL0C;;AAE9C,WAAOiB,MAAMG,MAAN,GAAe,CAAtB,EAA0B;AAAA;AAWzB;AACJ,CAdM;;AAgBP;AACA","file":"graphOpration.js","sourcesContent":["//Busca em Profundidade\r\nexport const DFS = (graph, vertex, discovered) => { \r\n    graph.incidentEdge(vertex).forEach( edge => {\r\n        let opposite = edge.opposite(vertex)\r\n\r\n        if( !discovered.has(opposite) ) {\r\n            discovered.set(opposite, edge)\r\n            DFS(graph, opposite, discovered)\r\n        }\r\n    } )\r\n}\r\n\r\n//Busca em Profundidade Completo\r\nexport const DFS_complete = (graph) => {\r\n    let forest = new Map()\r\n    for( let vertex of graph.vertices() ) {\r\n        if( !forest.has(vertex) ) {\r\n            DFS(graph, vertex, forest)\r\n        }\r\n    }\r\n\r\n    return forest\r\n}\r\n\r\nexport const constructPath = (origin, destination, discovered) => {\r\n    let path = []\r\n\r\n    if( discovered.has(destination) ) {\r\n        let step = destination\r\n        path.push(step)\r\n\r\n        while( step !== origin ) {\r\n            let edge = discovered.get(step)\r\n            let opposite = edge.opposite(step)\r\n            path.unshift(opposite)\r\n\r\n            step = opposite\r\n        }\r\n    }\r\n\r\n    return path\r\n}\r\n\r\n//Busca em Largura - sem nível\r\nexport const BFS = (graph, vertex, discovered) => {\r\n    let queue = [vertex]\r\n    while( queue.length > 0 ) {\r\n        let currentVertex = queue.shift()\r\n        \r\n        graph.incidentEdge(currentVertex).forEach( edge => {\r\n            let opposite = edge.opposite(currentVertex)\r\n\r\n            if( !discovered.has(opposite) ) {\r\n                discovered.set(opposite, edge)\r\n                queue.push(opposite)\r\n            }\r\n        } )\r\n    }\r\n}\r\n\r\n//TRABALHO Dijkstra 1.5 pts\r\n/**\r\n * Não pode adicionar nenhuma propriedade ao Vertex e ao Edge (usar o que já tem)\r\n * Criar uma estimativa, como nos métodos acima\r\n */"]}