{"version":3,"sources":["../../src/util/graphOpration.js"],"names":["DFS","graph","vertex","discovered","incidentEdge","forEach","opposite","edge","has","set","constructPath","origin","destination","path","step","push","get","unshift","BFS","queue","currentVertex","shift","length"],"mappings":";;;;;AAAO,IAAMA,oBAAM,SAANA,GAAM,CAACC,KAAD,EAAQC,MAAR,EAAgBC,UAAhB,EAA+B;AAAE;AAChDF,UAAMG,YAAN,CAAmBF,MAAnB,EAA2BG,OAA3B,CAAoC,gBAAQ;AACxC,YAAIC,WAAWC,KAAKD,QAAL,CAAcJ,MAAd,CAAf;;AAEA,YAAI,CAACC,WAAWK,GAAX,CAAeF,QAAf,CAAL,EAAgC;AAC5BH,uBAAWM,GAAX,CAAeH,QAAf,EAAyBC,IAAzB;AACAP,gBAAIC,KAAJ,EAAWK,QAAX,EAAqBH,UAArB;AACH;AACJ,KAPD;AAQH,CATM;;AAWA,IAAMO,wCAAgB,SAAhBA,aAAgB,CAACC,MAAD,EAASC,WAAT,EAAsBT,UAAtB,EAAqC;AAC9D,QAAIU,OAAO,EAAX;;AAEA,QAAIV,WAAWK,GAAX,CAAeI,WAAf,CAAJ,EAAkC;AAC9B,YAAIE,OAAOF,WAAX;AACAC,aAAKE,IAAL,CAAUD,IAAV;;AAEA,eAAOA,SAASH,MAAhB,EAAyB;AACrB,gBAAIJ,OAAOJ,WAAWa,GAAX,CAAeF,IAAf,CAAX;AACA,gBAAIR,WAAWC,KAAKD,QAAL,CAAcQ,IAAd,CAAf;AACAD,iBAAKI,OAAL,CAAaX,QAAb;;AAEAQ,mBAAOR,QAAP;AACH;AACJ;;AAED,WAAOO,IAAP;AACH,CAjBM;;AAmBA,IAAMK,oBAAM,SAANA,GAAM,CAACjB,KAAD,EAAQC,MAAR,EAAgBC,UAAhB,EAA+B;AAC9C,QAAIgB,QAAQ,CAACjB,MAAD,CAAZ;;AAD8C;AAG1C,YAAIkB,gBAAgBD,MAAME,KAAN,EAApB;;AAEApB,cAAMG,YAAN,CAAmBgB,aAAnB,EAAkCf,OAAlC,CAA2C,gBAAQ;AAC/C,gBAAIC,WAAWC,KAAKD,QAAL,CAAcc,aAAd,CAAf;;AAEA,gBAAI,CAACjB,WAAWK,GAAX,CAAeF,QAAf,CAAL,EAAgC;AAC5BH,2BAAWM,GAAX,CAAeH,QAAf,EAAyBC,IAAzB;AACAY,sBAAMJ,IAAN,CAAWT,QAAX;AACH;AACJ,SAPD;AAL0C;;AAE9C,WAAOa,MAAMG,MAAN,GAAe,CAAtB,EAA0B;AAAA;AAWzB;AACJ,CAdM","file":"graphOpration.js","sourcesContent":["export const DFS = (graph, vertex, discovered) => { //Busca em profundidade \r\n    graph.incidentEdge(vertex).forEach( edge => {\r\n        let opposite = edge.opposite(vertex)\r\n\r\n        if( !discovered.has(opposite) ) {\r\n            discovered.set(opposite, edge)\r\n            DFS(graph, opposite, discovered)\r\n        }\r\n    } )\r\n}\r\n\r\nexport const constructPath = (origin, destination, discovered) => {\r\n    let path = []\r\n\r\n    if( discovered.has(destination) ) {\r\n        let step = destination\r\n        path.push(step)\r\n\r\n        while( step !== origin ) {\r\n            let edge = discovered.get(step)\r\n            let opposite = edge.opposite(step)\r\n            path.unshift(opposite)\r\n\r\n            step = opposite\r\n        }\r\n    }\r\n\r\n    return path\r\n}\r\n\r\nexport const BFS = (graph, vertex, discovered) => {\r\n    let queue = [vertex]\r\n    while( queue.length > 0 ) {\r\n        let currentVertex = queue.shift()\r\n        \r\n        graph.incidentEdge(currentVertex).forEach( edge => {\r\n            let opposite = edge.opposite(currentVertex)\r\n\r\n            if( !discovered.has(opposite) ) {\r\n                discovered.set(opposite, edge)\r\n                queue.push(opposite)\r\n            }\r\n        } )\r\n    }\r\n}"]}